# Interface Class Specification: Button

## Device class summary

> Status: **implemented**

This is a basic device class for buttons and other binary (on/off) sensors/channels. No explicit meaning is necessarily ascribed to a given channel or group of channels. The number of channels is bounded and typically known at startup.

In many cases, buttons are associated with other interface classes: for example, a tracked controller may have several buttons on it. These associations should be reflected in the semantic data in the JSON device descriptor data.

Convention suggests that when a device provides logical "sets" of buttons (for instance, a left and a right controller with the same buttons), a documented offset separate them, when possible by a power of 2. (Thus, if there are two controllers on a device, and 7 buttons on each controller, the first controller's buttons would start at channel 0, and the second's would start at channel 8 for convenience, harmlessly leaving channel 7 unused).

Occasionally they are used to report a binary state of some other sort than a button-style interaction.

### Examples
- Gamepad buttons
- Programmable keypads (for instance, X-keys devices <http://xkeys.com> )

### Relation to other classes
**Factoring**: This interface class is for use with things that are substantially like buttons - either on or off, and from which a user would want to receive down/up events. Non-binary-valued data should at least be promoted to an Analog interface.

**From other classes**: Thresholding might be performed to turn analog values into button values.

**To other classes**: VRPN provides a ButtonFly device that simulates a tracker controlled by button channels.

## Messages

### Button Change
#### Data
- Sensor/channel number
- New binary state - pressed or not pressed

#### Rationale
This is the basic report for this interface class. It reports the state of a single button on input from the device.

### Button State
#### Data
- Number of buttons
- Array of state

#### Rationale
This is an internally-generated message sent from the server to a new client on connection automatically. It provides the initial state of all button channels on the interface, so that the button change messages have context.

Since it is automatically generated by internal state maintenance in the server, no explicit sending of this message is required or possible from devices. Furthermore, since it serves to initialize state, on the client side it is handled by generating equivalent button change events for all included buttons. Thus, no explicit handling of this message is required in OSVR clients.
